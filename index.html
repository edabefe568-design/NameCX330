<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D éº»å°† v11.0 - å®Œç¾è§†è§’ç»ˆç»“ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #2e8b57; font-family: "Microsoft YaHei", sans-serif; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none; z-index: 10;
            border: 1px solid rgba(255,255,255,0.2); width: 280px;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 24px; font-weight: bold; text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .status-dot { height: 12px; width: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; vertical-align: middle; }
        .input_video { display: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="info">
    <h3 style="margin:0 0 10px 0;">ğŸ€„ï¸ å››äººéº»å°† v11.0</h3>
    <p><b>çŠ¶æ€:</b> <span id="status_text">ç‰Œå±€å‡†å¤‡å°±ç»ª</span></p>
    <hr style="border-color: #555;">
    <div style="font-size: 14px; line-height: 1.8;">
        <div><span class="status-dot" id="dot-grab" style="background:#555"></span> <b>æåˆ (ğŸ‘Œ)</b>: æŠ“å– / å‡ºç‰Œ</div>
        <div><span class="status-dot" id="dot-view" style="background:#555"></span> <b>å¼ å¼€ (âœ‹)</b>: æ—‹è½¬è§†è§’</div>
    </div>
</div>

<div id="loading">æ­£åœ¨è°ƒæ•´å››æ–¹åº§ä½...</div>
<video class="input_video"></video>

<script>
// --- 1. å›¾æ¡ˆç»˜åˆ¶å¼•æ“ ---
const TILE_PAINTER = {
    createTexture: function(type, val) {
        const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 320;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,256,320);
        ctx.strokeStyle = '#e8e8e8'; ctx.lineWidth = 2; ctx.strokeRect(4,4,248,312);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        
        if (type === 'é¥¼') this.drawDots(ctx, val);
        else if (type === 'æ¡') this.drawBamboos(ctx, val);
        else if (type === 'ä¸‡') this.drawWan(ctx, val);
        else if (type === 'å­—') this.drawHonors(ctx, val);

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace; 
        tex.flipY = true; 
        return tex;
    },
    colors: { R: '#d60000', B: '#0044bb', G: '#008800' }, 
    drawDots: function(ctx, val) {
        const {R, B, G} = this.colors;
        const circle = (x, y, r, cO, cI) => {
            ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=cO; ctx.fill();
            if(cI){ ctx.beginPath(); ctx.arc(x,y,r*0.4,0,Math.PI*2); ctx.fillStyle=cI; ctx.fill(); }
            ctx.beginPath(); ctx.arc(x,y,r*0.75,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.lineWidth=3; ctx.stroke();
        };
        if(val===1) { 
            ctx.beginPath(); ctx.arc(128,160,70,0,Math.PI*2); ctx.fillStyle=G; ctx.fill();
            ctx.beginPath(); ctx.arc(128,160,45,0,Math.PI*2); ctx.fillStyle=R; ctx.fill();
            ctx.strokeStyle='white'; ctx.lineWidth=4; for(let i=0;i<12;i++){let a=(i/12)*Math.PI*2; ctx.beginPath(); ctx.moveTo(128,160); ctx.lineTo(128+Math.cos(a)*70, 160+Math.sin(a)*70); ctx.stroke();}
            return;
        }
        const pos={
            2:[[128,80,B,R],[128,240,G,R]], 3:[[60,60,B,R],[128,160,R,R],[196,260,G,R]],
            4:[[70,80,B,G],[186,80,B,G],[70,240,G,B],[186,240,G,B]],
            5:[[70,70,B,G],[186,70,B,G],[128,160,R,R],[70,250,G,B],[186,250,G,B]],
            6:[[70,70,G,R],[186,70,G,R],[70,160,R,R],[186,160,R,R],[70,250,R,R],[186,250,R,R]],
            7:[[60,65,G,B],[128,85,G,B],[196,105,G,B],[70,180,R,R],[186,180,R,R],[70,260,R,R],[186,260,R,R]],
            8:[[70,60,B,B],[186,60,B,B],[70,126,B,B],[186,126,B,B],[70,192,B,B],[186,192,B,B],[70,260,B,B],[186,260,B,B]],
            9:[[60,60,B,B],[128,60,B,B],[196,60,B,B],[60,160,R,R],[128,160,R,R],[196,160,R,R],[60,260,G,G],[128,260,G,G],[196,260,G,G]]
        };
        (pos[val]||[]).forEach(p=>circle(p[0],p[1],24,p[2],p[3]));
    },
    drawBamboos: function(ctx, val) {
        const {R, B, G} = this.colors;
        if (val === 1) { 
            ctx.fillStyle='#dcb'; ctx.beginPath(); ctx.arc(128,180,40,0,Math.PI*2); ctx.fill();
            ctx.font='160px Arial'; ctx.fillStyle=G; ctx.fillText('ğŸ¦',128,160); return; 
        }
        const stick=(x,y,c)=>{
            ctx.lineCap='round'; ctx.lineWidth=14; ctx.strokeStyle=c; ctx.beginPath(); ctx.moveTo(x,y-26); ctx.lineTo(x,y+26); ctx.stroke();
            ctx.strokeStyle='white'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x-6,y); ctx.lineTo(x+6,y); ctx.stroke();
        };
        const pos={
            2:[[128,80,B],[128,240,G]], 3:[[128,60,B],[70,240,G],[186,240,G]],
            4:[[70,80,B],[186,80,G],[70,240,G],[186,240,B]],
            5:[[70,70,G],[186,70,B],[128,160,R],[70,250,B],[186,250,G]],
            6:[[70,60,G],[128,60,G],[186,60,G],[70,240,G],[128,240,G],[186,240,G]],
            7:[[128,60,R],[70,140,G],[128,140,B],[186,140,G],[70,240,G],[128,240,B],[186,240,G]],
            8:[[70,60,G],[128,60,G],[186,60,G],[70,160,R],[186,160,R],[70,260,B],[128,260,B],[186,260,B]],
            9:[[70,60,R],[128,60,B],[186,60,G],[70,160,R],[128,160,B],[186,160,G],[70,260,R],[128,260,B],[186,260,G]]
        };
        (pos[val]||pos[2]).forEach(p=>stick(p[0],p[1],p[2]));
    },
    drawWan: function(ctx, val) {
        const {R, B} = this.colors;
        const c = ['','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­','ä¸ƒ','å…«','ä¹'];
        ctx.font='bold 90px "Microsoft YaHei"'; ctx.fillStyle=B; ctx.fillText(c[val],128,90);
        ctx.font='bold 120px "Microsoft YaHei"'; ctx.fillStyle=R; ctx.fillText('è¬',128,230);
    },
    drawHonors: function(ctx, val) {
        const {R, B, G} = this.colors;
        if (val === 'ç™½') { ctx.strokeStyle=B; ctx.lineWidth=6; ctx.strokeRect(45,45,166,230); ctx.lineWidth=3; ctx.strokeRect(55,55,146,210); return; }
        let c = B; if(val==='ä¸­')c=R; if(val==='å‘')c=G;
        ctx.font='bold 140px "Microsoft YaHei"'; ctx.fillStyle=c; ctx.fillText(val,128,160);
    }
};

// --- 2. 3D é€»è¾‘ ---
let camera, scene, renderer;
let myHand = [], opponentHands = [];
let raycaster, mouse;
let selectedTile = null;
let handCursor;
let tileGeometry = null;

const TILE_W = 2.2, TILE_H = 3.0, TILE_D = 1.4, BEVEL = 0.1;
const FACE_Z = (TILE_D / 2) + BEVEL + 0.02;

let isPinching = false, cameraAngle = 0, targetCameraAngle = 0, previousPalmX = null;

function init3D() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2e8b57);
    scene.fog = new THREE.Fog(0x2e8b57, 40, 150);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    updateCameraPosition();

    const ambient = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffeebb, 1.0);
    dirLight.position.set(5, 30, 20); dirLight.castShadow = true; 
    dirLight.shadow.mapSize.set(2048, 2048); scene.add(dirLight);

    // å¤§å·éº»å°†æ¡Œ
    const table = new THREE.Mesh(new THREE.PlaneGeometry(120, 120), new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness: 0.9 }));
    table.rotation.x = -Math.PI / 2; table.position.y = -2; table.receiveShadow = true; scene.add(table);

    // æ¡Œè¾¹
    const borderMat = new THREE.MeshStandardMaterial({color:0x3e1b07});
    const borderGeo = new THREE.BoxGeometry(122, 2, 2);
    const b1 = new THREE.Mesh(borderGeo, borderMat); b1.position.set(0,-2,-60); scene.add(b1);
    const b2 = new THREE.Mesh(borderGeo, borderMat); b2.position.set(0,-2,60); scene.add(b2);
    const b3 = new THREE.Mesh(new THREE.BoxGeometry(2,2,120), borderMat); b3.position.set(-60,-2,0); scene.add(b3);
    const b4 = new THREE.Mesh(new THREE.BoxGeometry(2,2,120), borderMat); b4.position.set(60,-2,0); scene.add(b4);

    handCursor = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 }));
    scene.add(handCursor);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const shape = new THREE.Shape();
    const w=TILE_W, h=TILE_H, r=0.3, x=-w/2, y=-h/2;
    shape.moveTo(x,y+r); shape.lineTo(x,y+h-r); shape.quadraticCurveTo(x,y+h,x+r,y+h); shape.lineTo(x+w-r,y+h); shape.quadraticCurveTo(x+w,y+h,x+w,y+h-r); shape.lineTo(x+w,y+r); shape.quadraticCurveTo(x+w,y,x+w-r,y); shape.lineTo(x+r,y); shape.quadraticCurveTo(x,y,x,y+r);
    tileGeometry = new THREE.ExtrudeGeometry(shape, { depth: TILE_D, bevelEnabled: true, bevelThickness: BEVEL, bevelSize: BEVEL, bevelSegments: 2 });
    tileGeometry.center();

    initGame();
    document.getElementById('loading').style.display = 'none';
}

function createTileMesh(tileData) {
    const texture = TILE_PAINTER.createTexture(tileData.type, tileData.val);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xfffff8, roughness: 0.2 });
    const backMat = new THREE.MeshStandardMaterial({ color: 0x009944, roughness: 0.2 });
    const faceMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });

    const group = new THREE.Group();
    const body = new THREE.Mesh(tileGeometry, bodyMat); body.castShadow = true; body.receiveShadow = true; group.add(body);
    const back = new THREE.Mesh(new THREE.BoxGeometry(TILE_W-0.1, TILE_H-0.1, 0.1), backMat); back.position.z = -FACE_Z; group.add(back);
    const face = new THREE.Mesh(new THREE.PlaneGeometry(TILE_W-0.3, TILE_H-0.3), faceMat); face.position.z = FACE_Z; face.renderOrder = 1; group.add(face);

    group.userData = { isTile: true, data: tileData };
    body.userData = face.userData = back.userData = { parentTile: group };
    return group;
}

// --- 3. æ¸¸æˆé€»è¾‘ ---
function initGame() {
    const allTiles = generateTileData();
    
    // ç©å®¶ (å—)
    for(let i=0; i<14; i++) {
        const tile = createTileMesh(allTiles.pop());
        myHand.push(tile); scene.add(tile);
    }
    reorderTiles(); 

    // å¯¹å®¶ (åŒ—) - Zè½´æ’åˆ—
    // æ—‹è½¬ Math.PI (180åº¦)ï¼Œè®©ç»¿èƒŒé¢å¯¹ä¸­å¿ƒ
    setupOpponentHandSimple(allTiles, 13, new THREE.Vector3(0, -0.5, -28), Math.PI, 'z');
    
    // ä¸Šå®¶ (è¥¿/å·¦) - Xè½´æ’åˆ—
    // æ—‹è½¬ -Math.PI/2 (-90åº¦)ï¼Œè®©ç»¿èƒŒé¢å¯¹ä¸­å¿ƒ
    setupOpponentHandSimple(allTiles, 13, new THREE.Vector3(-32, -0.5, 0), -Math.PI/2, 'x');

    // ä¸‹å®¶ (ä¸œ/å³) - Xè½´æ’åˆ—
    // æ—‹è½¬ +Math.PI/2 (+90åº¦)ï¼Œè®©ç»¿èƒŒé¢å¯¹ä¸­å¿ƒ
    setupOpponentHandSimple(allTiles, 13, new THREE.Vector3(32, -0.5, 0), Math.PI/2, 'x');
}

function setupOpponentHandSimple(deck, count, startPos, rotationY, axis) {
    const spacing = TILE_W * 1.0; 
    const totalW = count * spacing;
    
    for(let i=0; i<count; i++) {
        const tile = createTileMesh(deck.pop());
        tile.rotation.set(0, rotationY, 0); 
        
        const offset = -totalW/2 + spacing/2 + i*spacing;
        
        if (axis === 'z') {
            // å¯¹é¢ç©å®¶: æ²¿ X è½´åˆ†å¸ƒ
            tile.position.set(startPos.x + offset, startPos.y, startPos.z);
        } else {
            // å·¦å³ç©å®¶: æ²¿ Z è½´åˆ†å¸ƒ
            tile.position.set(startPos.x, startPos.y, startPos.z + offset);
        }
        scene.add(tile);
        opponentHands.push(tile);
    }
}

function generateTileData() {
    const d = [];
    ['ä¸‡','æ¡','é¥¼'].forEach(s=>{ for(let i=1;i<=9;i++) for(let k=0;k<4;k++) d.push({type:s,val:i}) });
    ['ä¸œ','å—','è¥¿','åŒ—','ä¸­','å‘','ç™½'].forEach(h=>{ for(let k=0;k<4;k++) d.push({type:'å­—',val:h}) });
    for(let i=d.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[d[i],d[j]]=[d[j],d[i]];}
    return d;
}

function reorderTiles() {
    const spacing = TILE_W * 1.1;
    const startX = -((myHand.length * spacing)/2) + spacing/2;
    myHand.forEach((tile, i) => {
        if (tile !== selectedTile) {
            const tx = startX + i * spacing;
            // ç©å®¶æ‰‹ç‰Œä½ç½® Z=25 (æ›´é å¤–)
            tile.position.lerp(new THREE.Vector3(tx, -0.5, 25), 0.2); 
            tile.rotation.set(-Math.PI/10, 0, 0); 
        }
    });
}

function updateCameraPosition() {
    cameraAngle += (targetCameraAngle - cameraAngle) * 0.05;
    // æ‘„åƒæœºæ‹‰è¿œåˆ° 52ï¼Œå‡é«˜åˆ° 45ï¼Œç¡®ä¿çœ‹æ¸…å…¨åœº
    const r = 52; 
    camera.position.x = r * Math.sin(cameraAngle);
    camera.position.z = r * Math.cos(cameraAngle) + 6;
    camera.position.y = 45; 
    camera.lookAt(0, -5, 0);
}

// --- æ‰‹åŠ¿è¯†åˆ« ---
function onResults(results) {
    reorderTiles();
    updateCameraPosition();
    
    const dotGrab = document.getElementById('dot-grab');
    const dotView = document.getElementById('dot-view');
    const statusText = document.getElementById('status_text');
    dotGrab.style.background = '#555'; dotView.style.background = '#555';

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const lm = results.multiHandLandmarks[0];
        const indexTip = lm[8]; const thumbTip = lm[4]; const pinkyTip = lm[20]; const wrist = lm[0];
        
        mouse.x = ((1 - indexTip.x) * 2) - 1;
        mouse.y = -(indexTip.y * 2) + 1;
        updateCursor();

        const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
        const palmOpenDist = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
        
        if (pinchDist < 0.06) {
            isPinching = true; previousPalmX = null;
            dotGrab.style.background = '#0f0'; statusText.innerText = "âœŠ æŠ“å–æ¨¡å¼";
            handCursor.material.color.set(0x00ff00);
            processGrab(true);
        } else if (!isPinching && palmOpenDist > 0.15) {
            isPinching = false; processGrab(false);
            dotView.style.background = '#00f'; statusText.innerText = "âœ‹ è§†è§’æ¨¡å¼";
            handCursor.material.color.set(0x0088ff);
            const currentX = lm[9].x;
            if (previousPalmX !== null && Math.abs(currentX - previousPalmX) > 0.003) {
                targetCameraAngle += ((1 - currentX) - (1 - previousPalmX)) * 4.0;
            }
            previousPalmX = currentX;
        } else {
            isPinching = false; processGrab(false); previousPalmX = null;
            statusText.innerText = "â˜ï¸ ç§»åŠ¨å…‰æ ‡";
            handCursor.material.color.set(0xffff00);
        }
    } else {
        statusText.innerText = "â³ å¯»æ‰¾æ‰‹åŠ¿..."; previousPalmX = null;
    }
    renderer.render(scene, camera);
}

function updateCursor() {
    raycaster.setFromCamera(mouse, camera);
    const plane = new THREE.Plane(new THREE.Vector3(0,0,1), -8);
    const target = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, target);
    if(target) handCursor.position.lerp(target, 0.4);
}

function processGrab(isGrabbing) {
    if (isGrabbing) {
        if (!selectedTile) {
            const intersects = raycaster.intersectObjects(myHand, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target) {
                    if (target.userData && target.userData.isTile) { selectedTile = target; break; }
                    if (target.userData && target.userData.parentTile) { selectedTile = target.userData.parentTile; break; }
                    target = target.parent;
                }
            }
        }
        if (selectedTile) {
            selectedTile.position.copy(handCursor.position);
            selectedTile.position.z = 15;
            selectedTile.rotation.x = -Math.PI / 6;
        }
    } else {
        if (selectedTile) {
            if (selectedTile.position.y > 5) discardTile(selectedTile);
            selectedTile = null;
        }
    }
}

function discardTile(tile) {
    const idx = myHand.indexOf(tile);
    if (idx > -1) myHand.splice(idx, 1);
    tile.userData = null;
    tile.position.set(Math.random()*10-5, Math.random()*5+5, -Math.random()*5);
    tile.rotation.set(-Math.PI/2, 0, Math.random()*3);
    setTimeout(() => {
        const t = createTileMesh(generateTileData()[0]);
        scene.add(t); myHand.push(t);
    }, 500);
}

const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
hands.onResults(onResults);
const video = document.getElementsByClassName('input_video')[0];
const cameraObj = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 1280, height: 720 });

init3D();
cameraObj.start();
</script>
</body>
</html>
